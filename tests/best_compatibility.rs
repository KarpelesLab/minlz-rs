/// Test that encode_best produces identical output to Go's s2.EncodeBest
///
/// This test ensures binary compatibility with the Go reference implementation
/// for the "best" compression mode. The Rust implementation is based on the Go
/// code, so outputs must be identical for the same input.

#[test]
fn test_encode_best_matches_go() {
    // Input test data
    const INPUT: &[u8] = b"This is a test file with some repeated content to compress.
The quick brown fox jumps over the lazy dog.
The quick brown fox jumps over the lazy dog.
The quick brown fox jumps over the lazy dog.
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
Binary compatibility testing with S2 compression format.
Binary compatibility testing with S2 compression format.
Binary compatibility testing with S2 compression format.
Performance benchmarking and optimization verification.
Performance benchmarking and optimization verification.
Performance benchmarking and optimization verification.
";

    // Expected output from Go's s2.EncodeBest (269 bytes)
    const EXPECTED_GO_OUTPUT: &[u8] = &[
        0xc1, 0x05, 0xf0, 0x66, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74,
        0x65, 0x73, 0x74, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6f,
        0x6e, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65,
        0x73, 0x73, 0x2e, 0x0a, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62,
        0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x73, 0x20,
        0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64,
        0x6f, 0x67, 0x11, 0x2d, 0x15, 0x00, 0x4c, 0x68, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69,
        0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20,
        0x61, 0x6d, 0x65, 0x74, 0x2c, 0x01, 0xb8, 0x5c, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75,
        0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c,
        0x69, 0x74, 0x11, 0x39, 0x15, 0x00, 0x64, 0x14, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x25,
        0x43, 0x20, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x25, 0x79, 0x01, 0x23,
        0x25, 0x77, 0x04, 0x53, 0x32, 0x35, 0x61, 0x04, 0x69, 0x6f, 0x01, 0xf9, 0x08, 0x72, 0x6d,
        0x61, 0x11, 0x39, 0x15, 0x00, 0x65, 0x08, 0x50, 0x65, 0x72, 0x05, 0x0b, 0x30, 0x6e, 0x63,
        0x65, 0x20, 0x62, 0x65, 0x6e, 0x63, 0x68, 0x6d, 0x61, 0x72, 0x6b, 0x01, 0x35, 0x30, 0x61,
        0x6e, 0x64, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6d, 0x69, 0x7a, 0x61, 0x74, 0x01, 0x32, 0x18,
        0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x05, 0x0d, 0x11, 0x38, 0x15, 0x00, 0x62,
    ];

    // Compress with Rust's encode_best
    let rust_output = minlz::encode_best(INPUT);

    // Compare outputs
    if rust_output != EXPECTED_GO_OUTPUT {
        // Print detailed comparison for debugging
        println!("\n=== MISMATCH DETECTED ===");
        println!("Go output:   {} bytes", EXPECTED_GO_OUTPUT.len());
        println!("Rust output: {} bytes", rust_output.len());

        // Find first difference
        let min_len = rust_output.len().min(EXPECTED_GO_OUTPUT.len());
        for i in 0..min_len {
            if rust_output[i] != EXPECTED_GO_OUTPUT[i] {
                println!("\nFirst difference at byte {}:", i);
                println!("  Go:   0x{:02x}", EXPECTED_GO_OUTPUT[i]);
                println!("  Rust: 0x{:02x}", rust_output[i]);

                // Show context (16 bytes before and after)
                let start = i.saturating_sub(16);
                let end = (i + 16).min(min_len);

                println!("\nContext (Go):");
                print!("  ");
                #[allow(clippy::needless_range_loop)]
                for j in start..end {
                    if j == i {
                        print!("[{:02x}] ", EXPECTED_GO_OUTPUT[j]);
                    } else {
                        print!("{:02x} ", EXPECTED_GO_OUTPUT[j]);
                    }
                }

                println!("\nContext (Rust):");
                print!("  ");
                #[allow(clippy::needless_range_loop)]
                for j in start..end {
                    if j == i {
                        print!("[{:02x}] ", rust_output[j]);
                    } else {
                        print!("{:02x} ", rust_output[j]);
                    }
                }
                println!("\n");
                break;
            }
        }

        if rust_output.len() != EXPECTED_GO_OUTPUT.len() {
            println!(
                "Length difference: {} bytes",
                (rust_output.len() as i32 - EXPECTED_GO_OUTPUT.len() as i32).abs()
            );
        }
    }

    assert_eq!(
        rust_output, EXPECTED_GO_OUTPUT,
        "Rust encode_best output must match Go s2.EncodeBest output exactly"
    );
}
